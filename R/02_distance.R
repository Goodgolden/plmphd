# Functions in For-loop --------------------------------------------------------

## 2.1 distance_df -------------------------------------------------------------
#' Distance Calculation for Matching
#'
#' @description This function calculates the distance between the training data and a test individual based on different matching methods, such as Euclidean distance, Mahalanobis distance, or single-time point matching. The function returns a distance dataframe with distances and optionally p-values, arranged from smallest to largest.
#'
#' @param lb_train \code{data.frame} The training dataset containing predictions or imputations from two-stage models (brokenstick model and linear model).
#' @param lb_test_ind \code{data.frame} The test individual’s data containing predictions or imputations from the two-stage models.
#' @param match_methods \code{character} The method for distance calculation. Options are \code{"euclidean"}, \code{"mahalanobis"}, or \code{"single"} for single-time matching.
#' @param match_time \code{numeric} The critical time point for single-time matching. This time must be included in the anchor time set. Not required for \code{"euclidean"} or \code{"mahalanobis"} methods.
#' @param id_var \code{character} The name of the ID variable in the dataset.
#' @param outcome_var \code{character} The name of the outcome variable in the dataset.
#' @param time_var \code{character} The name of the time variable in the dataset.
#' @param ... Additional arguments passed to the function.
#'
#' @return A \code{data.frame} containing the calculated distances and, for Mahalanobis distance, p-values, arranged from smallest to largest.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   distance_df(lb_train = train_data,
#'               lb_test_ind = test_individual_data,
#'               match_methods = "euclidean",
#'               id_var = "id",
#'               outcome_var = "height",
#'               time_var = "time")
#' }

distance_df <- function(lb_train,
                        lb_test_ind,
                        match_methods = c("euclidean", "mahalanobis", "single"),
                        match_time = NULL,
                        id_var,
                        outcome_var,
                        time_var,
                        ...) {
  outcome_var <- ensym(outcome_var)
  time_var <- ensym(time_var)
  id_var <- ensym(id_var)

  ## the matching subset
  lb_sub1 <- lb_train %>%
    pivot_wider(names_from = {{ id_var }},
                values_from = {{ outcome_var }}) %>%
    column_to_rownames(var = as.character({{ time_var }})) %>%
    mutate_all(as.numeric)

  center = as.numeric(unlist(lb_test_ind[, 3]))

  if (match_methods == "euclidean") {
    dist_df <<- euclidean_df(Dmatrix = lb_sub1,
                             center = center)
    # cat("\n using euclidean distance\n")
  }

  if (match_methods == "mahalanobis") {
      dist_df <<- mahalanobis_df(Dmatrix = lb_sub1,
                                 center = center)
    #  cat("\n using mahalanobis distance\n")
  }

  if (match_methods == "single") {
    if (is.null(match_time)) {
      stop("provide matching time points for single-time PLM methods")
    }
    dist_df <<- single_df(Dmatrix = lb_sub1,
                          match_time = match_time,
                          center = center)
    # cat("\n using single critical time point matching \n")
  }

  return(distance = dist_df)
}


## 2.2 matching ----------------------------------------------------------------
#' Finding the Matches Subset
#'
#' @description This function finds the matching individuals from the training dataset based on a distance dataframe, such as one generated by the \code{distance_df()} function. The function allows for filtering by p-value or selecting a specified number of matches, and can optionally generate a plot comparing the matching individual trajectories with the test individual.
#'
#' @param distance_df \code{data.frame} The distance dataframe containing calculated distances (and p-values, if applicable), typically arranged from smallest to largest.
#' @param train \code{data.frame} The training dataset to subset based on the matching process.
#' @param test_one \code{data.frame} The testing individual’s data for whom matching is performed.
#' @param id_var \code{character} The name of the ID variable in the dataset.
#' @param outcome_var \code{character} The name of the outcome variable in the dataset.
#' @param time_var \code{character} The name of the time variable in the dataset.
#' @param match_alpha \code{numeric} The p-value threshold for Mahalanobis distance matching. If \code{NULL}, it is ignored.
#' @param match_number \code{numeric} The number of matches to retrieve from the distance dataframe, specifically for Euclidean and Mahalanobis distance matching. If \code{NULL}, it is ignored.
#' @param match_plot \code{logical} Whether to generate a plot of the matching individuals’ trajectories. Defaults to \code{FALSE}.
#'
#' @return A list containing the following elements:
#' \itemize{
#'   \item \code{subset}: A \code{data.frame} containing the matched subset from the training dataset.
#'   \item \code{plot}: A \code{ggplot} object showing the trajectories of the matching individuals compared to the test individual if \code{match_plot = TRUE}, otherwise \code{NULL}.
#'   \item \code{id}: The ID of the target test individual.
#'   \item \code{alpha}: The alpha threshold used for Mahalanobis distance matching, or \code{NULL} if not used.
#'   \item \code{number}: The number of matches used for Euclidean or Mahalanobis distance matching, or \code{NULL} if not used.
#' }
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   matches <- match(distance_df = distance_data,
#'                    train = train_data,
#'                    test_one = test_individual_data,
#'                    id_var = "id",
#'                    outcome_var = "height",
#'                    time_var = "age",
#'                    match_alpha = 0.95,
#'                    match_plot = TRUE)
#' }

match <- function(distance_df = ddd,
                  train = train,
                  test_one,
                  id_var,
                  outcome_var,
                  time_var,
                  match_alpha = NULL,
                  match_number = NULL,
                  match_plot = FALSE) {

  outcome_var <- ensym(outcome_var)
  time_var <- ensym(time_var)
  id_var <- ensym(id_var)


  if (is.null(match_alpha)) {
    data <- distance_df %>%
      slice(1:match_number) %>%
      inner_join(train, by = as.character({{ id_var }}))
  }

  if (is.null(match_number)) {
    data <- distance_df %>%
      filter(pvalue >= match_alpha) %>%
      inner_join(train, by = as.character({{ id_var }}))
  }

  if (match_plot == TRUE) {

    matching_plot <- ggplot() +
      geom_line(data = data, aes(x = {{ time_var }}, y = {{ outcome_var }},
                    group = {{ id_var }}),
                color = "grey",
                linetype = "dashed") +
      geom_line(data = test_one,
                aes(x = {{time_var}}, y = {{outcome_var}}),
                color = "darkblue",
                linewidth = 1) +
      theme_bw()

    cat("\n plotting matching paired individual trajectories \n")
  } else {
    matching_plot = NULL
  }

  return(list(subset = data,
              plot = matching_plot,
              id = unique(test_one[[as_label(enquo(id_var))]]),
              alpha = match_alpha,
              number = match_number))
}

## 2.2.2 dis_match -----------------------------------------------------
#' Distance Calculation and Matching for People-Like-Me
#'
#' @description This function calculates distances between a test individual and the training dataset based on the specified distance method (Euclidean, Mahalanobis, or single-time matching). It then returns a subset of matching individuals from the training dataset based on the calculated distances or p-values and can optionally generate a plot of the matching trajectories.
#'
#' @param lb_train \code{data.frame} The training dataset containing predictions or imputations from the two-stage models (brokenstick and linear models).
#' @param lb_test_ind \code{data.frame} The testing individual’s dataset containing predictions or imputations from the two-stage models.
#' @param train \code{data.frame} The original training dataset used to extract the matched individuals.
#' @param match_methods \code{character} The distance calculation method. Options are \code{"euclidean"}, \code{"mahalanobis"}, or \code{"single"} (for single-time matching).
#' @param id_var \code{character} The name of the ID variable in the dataset.
#' @param outcome_var \code{character} The name of the outcome variable in the dataset.
#' @param time_var \code{character} The name of the time variable in the dataset.
#' @param match_alpha \code{numeric} The p-value threshold for Mahalanobis distance matching. If \code{NULL}, it is ignored.
#' @param match_number \code{numeric} The number of matches to retrieve from the distance dataframe for Euclidean or Mahalanobis distance matching. If \code{NULL}, it is ignored.
#' @param match_time \code{numeric} The critical time point for single-time matching. This time must be included in the anchor time set. Not required for Euclidean and Mahalanobis methods.
#' @param match_plot \code{logical} Whether to generate a plot of the matching individuals' trajectories. Defaults to \code{FALSE}.
#' @param ... Additional arguments passed to the function.
#'
#' @return A list containing:
#' \itemize{
#'   \item \code{subset}: A \code{data.frame} of the matched subset from the training dataset based on the chosen matching method.
#'   \item \code{target}: The \code{data.frame} of the test individual data.
#'   \item \code{plot}: A \code{ggplot} object showing the matching individual trajectories compared to the test individual if \code{match_plot = TRUE}, otherwise \code{NULL}.
#' }
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   matches <- dis_match(lb_train = train_pred,
#'                        lb_test_ind = test_pred,
#'                        train = train_data,
#'                        match_methods = "euclidean",
#'                        id_var = "id",
#'                        outcome_var = "height",
#'                        time_var = "age",
#'                        match_number = 5,
#'                        match_plot = TRUE)
#' }

dis_match <- function(lb_train,
                      lb_test_ind,
                      train = train,
                      match_methods = c("euclidean", "mahalanobis", "single"),
                      id_var,
                      outcome_var,
                      time_var,
                      match_alpha = NULL,
                      match_number = NULL,
                      match_time = NULL,
                      match_plot,
                      ...) {
  outcome_var <- ensym(outcome_var)
  time_var <- ensym(time_var)
  id_var <- ensym(id_var)
  ## the matching subset
  lb_sub1 <- lb_train %>%
    pivot_wider(names_from = {{ id_var }},
                values_from = {{ outcome_var }}) %>%
    column_to_rownames(var = as.character({{ time_var }})) %>%
    mutate_all(as.numeric)

  center = as.numeric(unlist(lb_test_ind[, outcome_var]))

  if (match_methods == "euclidean") {
    # dist_df <<- lb_sub1 %>%
    #   apply(2, norm, type = "2") %>%
    #   as.data.frame() %>%
    #   dplyr::select(diff = 1) %>%
    #   rownames_to_column("id") %>%
    #   arrange(diff) %>%
    #   slice(1:match_number)

    dist_df <<- euclidean_df(Dmatrix = lb_sub1,
                             center = center)
    # cat("\n using euclidean distance\n")
  }

  if (match_methods == "mahalanobis") {
    dist_df <<- mahalanobis_df(Dmatrix = lb_sub1,
                               center = center)
    # cat("\n using mahalanobis distance\n")
  }

  if (match_methods == "single") {
    if (is.null(match_time)) {
      stop("provide matching time points for single-time PLM methods")
    }
    dist_df <<- single_df(Dmatrix = lb_sub1,
                          match_time = match_time,
                          center = center)
    # cat("\n using single critical time point matching \n")
  }

  if (is.null(match_alpha)) {
    data1 <- dist_df %>%
      as.data.frame() %>%
      mutate(ww = 1 / diff) %>%
      slice(1:match_number) %>%
      inner_join(train, by = as.character({{ id_var }}))
  }

  if (is.null(match_number)) {
    data1 <- dist_df %>%
      as.data.frame() %>%
      mutate(ww = 1 / diff) %>%
      filter(pvalue >= match_alpha) %>%
      inner_join(train, by = as.character({{ id_var }}))
  }

  if (match_plot == TRUE) {

    matching_plot <- ggplot() +
      geom_line(data = data1, aes(x = {{ time_var }}, y = {{ outcome_var }},
                                 group = {{ id_var }}),
                color = "grey",
                linetype = "dashed") +
      geom_line(data = lb_test_ind,
                aes(x = {{time_var}}, y = {{outcome_var}}),
                color = "darkblue",
                linewidth = 1) +
      theme_bw()

    cat("\n plotting matching paired individual trajectories \n")
  } else {
    matching_plot = NULL
  }

  return(list(subset = data1,
              target = lb_test_ind,
              plot = matching_plot))
}



## 2.3 dyn_match --------------------------------------------------------------
#' Dynamic Matching Function for People-Like-Me
#'
#' @description This function performs dynamic matching between a test individual and training data based on specified distance methods (Euclidean, Mahalanobis, or single-time point matching). The function returns a subset of matched individuals and can optionally generate a plot showing the trajectories of the matching individuals.
#'
#' @param lb_train \code{data.frame} The training dataset containing predictions or imputations from two-stage models (brokenstick and linear models).
#' @param lb_test_ind \code{data.frame} The testing individual's dataset containing predictions or imputations from the two-stage models.
#' @param train \code{data.frame} The original training dataset used to extract the matched individuals.
#' @param match_methods \code{character} The method used for distance calculation. Options are \code{"euclidean"}, \code{"mahalanobis"}, or \code{"single"} (for single-time matching).
#' @param id_var \code{character} The name of the ID variable in the dataset.
#' @param outcome_var \code{character} The name of the outcome variable in the dataset.
#' @param time_var \code{character} The name of the time variable in the dataset.
#' @param match_alpha \code{numeric} The p-value threshold for Mahalanobis distance matching. If \code{NULL}, this parameter is ignored.
#' @param match_number \code{numeric} The number of matches to retrieve from the distance dataframe, specifically for Euclidean or Mahalanobis distance matching. If \code{NULL}, this parameter is ignored.
#' @param match_time \code{numeric} The critical time point for single-time matching. This must be specified for single-time matching and included in the anchor time set.
#' @param match_plot \code{logical} Whether to generate a plot of the matching individuals' trajectories. Defaults to \code{FALSE}.
#' @param ... Additional arguments passed to the function.
#'
#' @return A list containing:
#' \itemize{
#'   \item \code{subset}: A \code{data.frame} of the matched subset from the training dataset based on the selected matching method.
#'   \item \code{plot}: A \code{ggplot} object showing the matching individual trajectories if \code{match_plot = TRUE}, otherwise \code{NULL}.
#' }
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   matches <- dyn_match(lb_train = train_pred,
#'                        lb_test_ind = test_pred,
#'                        train = train_data,
#'                        match_methods = "euclidean",
#'                        id_var = "id",
#'                        outcome_var = "height",
#'                        time_var = "age",
#'                        match_number = 5,
#'                        match_plot = TRUE)
#' }

dyn_match <- function(lb_train,
                      lb_test_ind,
                      train = train,
                      match_methods = c("euclidean", "mahalanobis", "single"),
                      id_var,
                      outcome_var,
                      time_var,
                      match_alpha = NULL,
                      match_number = NULL,
                      match_time = NULL,
                      match_plot,
                      ...) {

  outcome_var <- ensym(outcome_var)
  time_var <- ensym(time_var)
  id_var <- ensym(id_var)

  ## the matching subset
  # lb_sub1 <- lb_train %>%
  #   pivot_wider(names_from = {{ id_var }},
  #               values_from = {{ outcome_var }}) %>%
  #   column_to_rownames(var = as.character({{ time_var }})) %>%
  #   mutate_all(as.numeric)
  # center = as.numeric(unlist(lb_test_ind[, outcome_var]))

  center = as.numeric(unlist(lb_test_ind$predicted_y))

  if (match_methods == "euclidean") {
    dist_df <<- lb_train %>%
      apply(2, norm, type = "2") %>%
      as.data.frame() %>%
      dplyr::select(diff = 1) %>%
      rownames_to_column("id") %>%
      arrange(diff) %>%
      slice(1:match_number)
    # cat("\n using euclidean distance\n")
  }


  # Wed Feb 28 22:52:05 2024 ------------------------------
  ## need to change the function to work
  if (match_methods == "mahalanobis") {
    def <- nrow(lb_train)
    df <- lb_train %>%
      as.matrix() %>%
      t()

    x <- sweep(df, 2L, center)
    invcov <- MASS::ginv(cov(df))

    value <- rowSums(x %*% invcov * x)
    pvalue <- pchisq(value, df = def, lower.tail = FALSE)
    dist_df <<- data.frame(diff = value,
                            pvalue = pvalue) %>%
      arrange(desc(pvalue)) %>%
      rownames_to_column("id")

    # dist_df <<- mahalanobis_df(Dmatrix = lb_sub1,
    #                            center = center)
    # cat("\n using mahalanobis distance\n")
  }

  if (match_methods == "single") {
    if (is.null(match_time)) {
      stop("provide matching time points for single-time PLM methods")
    }
    dist_df <<- single_df(Dmatrix = lb_train,
                          match_time = match_time,
                          center = center)
    # cat("\n using single critical time point matching \n")
  }

  if (is.null(match_alpha)) {
    data1 <- dist_df %>%
      as.data.frame() %>%
      mutate(ww = 1 / diff) %>%
      slice(1:match_number) %>%
      inner_join(train, by = as.character({{ id_var }}))
  }

  if (is.null(match_number)) {
    data1 <- dist_df %>%
      as.data.frame() %>%
      mutate(ww = 1 / diff) %>%
      filter(pvalue >= match_alpha) %>%
      inner_join(train, by = as.character({{ id_var }}))
  }

  if (match_plot == TRUE) {

    matching_plot <- ggplot() +
      geom_line(data = data1, aes(x = {{ time_var }}, y = {{ outcome_var }},
                                  group = {{ id_var }}),
                color = "grey",
                linetype = "dashed") +
      # geom_line(data = lb_test_ind,
      #           aes(x = {{time_var}}, y = {{outcome_var}}),
      #           color = "darkblue",
      #           linewidth = 1) +
      theme_bw()

    # cat("\n plotting matching paired individual trajectories \n")
  } else {
    matching_plot = NULL
  }

  return(list(subset = data1, plot = matching_plot))
}








